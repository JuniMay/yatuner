# -*- coding: utf-8 -*-

# Copyright (c) 2022 Synodic Month, Juni May
# yaTuner is licensed under Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#          http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
# EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
# MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
# See the Mulan PSL v2 for more details.

import time


def generate(filename: str) -> None:
    file = open(filename, 'w', encoding='utf-8')

    t = time.asctime(time.localtime(time.time()))

    content = f'''# -*- coding: utf-8 -*-

################################################################################
# yaTuner configuration file
# This file is auto generated by yaTuner.
# {t}
################################################################################

import logging
import yatuner
import os
from typing import Any, Dict, Mapping, Sequence

cc = 'gcc'
build_dir = './build'  # building directory for executable file.
workspace = './workspace'  # workspace to store tuning result.
metric = 'duration_time'  # used with `perf()` to get the target result

# making building directory if necessary
if not os.path.isdir(build_dir):
    os.mkdir(build_dir)

# you can replace these with appointed optimizers/parameters.
optimizers = yatuner.utils.fetch_gcc_optimizers(cc=cc)
parameters = yatuner.utils.fetch_gcc_parameters(cc=cc)

################################################################################


################################################################################
# defining compiling process
def comp(optimizers: Sequence[str], parameters: Mapping,
         additional: str) -> None:
    """Compilation process definition.

    Args:
        optimizers (Sequence[str]): list of on/off options.
        parameters (Mapping): list of options with parameters.
        additional (str): additional options.

    Raises:
        NotImplementedError: for not implemented
    """
    raise NotImplementedError("You need to tell yatuner how to compile.")


# run executable file and return a value representing its performance/size/etc.
def run() -> float:
    """Running executable file.

    Raises:
        NotImplementedError: for not implemented

    Returns:
        float: a number indicating the performance/codesize/etc of the program.
    """
    raise NotImplementedError("You need to tell yatuner how to run.")


# fetch performance counters or features of the program (for linUCB)
def perf() -> Dict[str, Any]:
    """Fetch the features of the program.

    Raises:
        NotImplementedError: for not implemented

    Returns:
        Dict[str, Any]: feature pairs.
    """
    raise NotImplementedError()


# defining tuner
tuner = yatuner.Tuner(call_compile=comp,
                      call_running=run,
                      call_perf=perf,
                      optimizers=optimizers,
                      parameters=parameters,
                      workspace=workspace,
                      log_level=logging.INFO,
                      norm_range=1.0)
################################################################################

################################################################################
# tuning process
tuner.initialize()
tuner.test_run(num_samples=500, warmup=0)
tuner.hypotest_optimizers(num_samples=5)
tuner.hypotest_parameters(num_samples=5)
# tuner.optimize(num_samples=10, num_epochs=50) # using bayesian optimization
tuner.optimize_linUCB(alpha=0.25,
                      num_bins=30,
                      num_epochs=200,
                      nth_choice=4,
                      metric=metric)  # using linUCB
tuner.run(num_samples=50)
tuner.plot_data()
################################################################################
    '''

    file.write(content)

    file.close()