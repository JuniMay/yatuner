import GPy
import GPyOpt
from numpy.random import seed
import matplotlib
import os
from bitarray import bitarray
from yatuner.compiler import Gcc
from typing import List, NoReturn
from utils import fetch_file_size


options = [
    'aggressive-loop-optimizations',
    'align-functions',
    'align-jumps',
    'align-labels',
    'align-loops',
    'associative-math',
    'asynchronous-unwind-tables',
    'auto-inc-dec',
    'branch-count-reg',
    'branch-probabilities',
    'branch-target-load-optimize',
    'btr-bb-exclusive',
    'caller-saves',
    'code-hoisting',
    'combine-stack-adjustments',
    'compare-elim',
    'conserve-stack',
    'cprop-registers',
    'crossjumping',
    'cse-follow-jumps',
    'cx-fortran-rules',
    'cx-limited-range',
    'dce',
    'defer-pop',
    'delayed-branch',
    'delete-dead-exceptions',
    'delete-null-pointer-checks',
    'devirtualize',
    'devirtualize-speculatively',
    'dse',
    'early-inlining',
    'exceptions',
    'expensive-optimizations',
    'fast-math',
    'finite-math-only',
    'float-store',
    'forward-propagate',
    'fp-int-builtin-inexact',
    'function-cse',
    'gcse',
    'gcse-after-reload',
    'gcse-las',
    'gcse-lm',
    'gcse-sm',
    'graphite',
    'graphite-identity',
    'guess-branch-probability',
    'handle-exceptions',
    'hoist-adjacent-loads',
    'if-conversion',
    'indirect-inlining',
    'inline',
    'inline-atomics',
    'inline-functions',
    'inline-functions-called-once',
    'inline-small-functions',
    'ipa-bit-cp',
    'ipa-cp',
    'ipa-cp-clone',
    'ipa-icf',
    'ipa-icf-functions',
    'ipa-icf-variables',
    'ipa-profile',
    'ipa-pta',
    'ipa-pure-const',
    'ipa-ra',
    'ipa-reference',
    'ipa-sra',
    'ipa-vrp',
    'ira-hoist-pressure',
    'ira-loop-pressure',
    'ira-share-save-slots',
    'ira-share-spill-slots',
    'isolate-erroneous-paths-attribute',
    'isolate-erroneous-paths-dereference',
    'ivopts',
    'jump-tables',
    'keep-gc-roots-live',
    'lifetime-dse',
    'limit-function-alignment',
    'live-range-shrinkage',
    'loop-interchange',
    'loop-nest-optimize',
    'loop-parallelize-all',
    'loop-unroll-and-jam',
    'lra-remat',
    'math-errno',
    'modulo-sched',
    'modulo-sched-allow-regmoves',
    'move-loop-invariants',
    'non-call-exceptions',
    'nothrow-opt',
    'omit-frame-pointer',
    'opt-info',
    'optimize-sibling-calls',
    'optimize-strlen',
    'pack-struct',
    'partial-inlining',
    'peel-loops',
    'peephole',
    'plt',
    'predictive-commoning',
    'prefetch-loop-arrays',
    'printf-return-value',
    'reciprocal-math',
    'associative-math',
    'reg-struct-return',
    'rename-registers',
    'reorder-blocks',
    'reorder-blocks-and-partition',
    'reorder-functions',
    'rerun-cse-after-loop',
    'reschedule-modulo-scheduled-loops',
    'rounding-math',
    'rtti',
    'sched-critical-path-heuristic',
    'sched-dep-count-heuristic',
    'sched-group-heuristic',
    'sched-interblock',
    'sched-last-insn-heuristic',
    'sched-pressure',
    'sched-rank-heuristic',
    'sched-spec',
    'sched-spec-insn-heuristic',
    'sched-spec-load',
    'sched-spec-load-dangerous',
    'sched-stalled-insns',
    'sched-stalled-insns-dep',
    'sched2-use-superblocks',
    'schedule-fusion',
    'schedule-insns',
    'section-anchors',
    'sel-sched-pipelining',
    'sel-sched-pipelining-outer-loops',
    'sel-sched-reschedule-pipelined',
    'selective-scheduling',
    'set-stack-executable',
    'short-enums',
    'short-wchar',
    'shrink-wrap',
    'shrink-wrap-separate',
    'signaling-nans',
    'signed-zeros',
    'single-precision-constant',
    'split-ivs-in-unroller',
    'split-loops',
    'split-paths',
    'split-wide-types',
    'ssa-backprop',
    'ssa-phiopt',
    'stack-clash-protection',
    'stack-protector',
    'stack-protector-all',
    'stack-protector-explicit',
    'stack-protector-strong',
    'stdarg-opt',
    'store-merging',
    'strict-aliasing',
    'strict-enums',
    'strict-volatile-bitfields',
    'thread-jumps',
    'no-threadsafe-statics',
    'tracer',
    'trapping-math',
    'trapv',
    'tree-bit-ccp',
    'tree-builtin-call-dce',
    'tree-ccp',
    'tree-ch',
    'tree-coalesce-vars',
    'tree-copy-prop',
    'tree-cselim',
    'tree-dce',
    'tree-dominator-opts',
    'tree-dse',
    'tree-forwprop',
    'tree-fre',
    'tree-loop-distribute-patterns',
    'tree-loop-distribution',
    'tree-loop-if-convert',
    'tree-loop-im',
    'tree-loop-ivcanon',
    'tree-loop-optimize',
    'tree-loop-vectorize',
    'tree-lrs',
    'tree-partial-pre',
    'tree-phiprop',
    'tree-pre',
    'tree-pta',
    'tree-reassoc',
    'tree-scev-cprop',
    'tree-sink',
    'tree-slp-vectorize',
    'tree-slsr',
    'tree-sra',
    'tree-switch-conversion',
    'tree-tail-merge',
    'tree-ter',
    'tree-vectorize',
    'tree-vrp',
    'unconstrained-commons',
    'unroll-all-loops',
    'unroll-loops',
    'unsafe-math-optimizations',
    'unswitch-loops',
    'unwind-tables',
    'var-tracking',
    'var-tracking-assignments',
    'var-tracking-assignments-toggle',
    'var-tracking-uninit',
    'variable-expansion-in-unroller',
    'vpt',
    'web',
    'wrapv',
    'wrapv-pointer',
]


def gen_optimization_option_list(option_flag: bitarray) -> List[str]:
    res: List[str] = []
    for i in range(len(option_flag)):
        if option_flag[i] == 1:
            res.append(options[i])

    return res


def gen_optimization_option_list_from_list(option_list: List[int]) -> List[str]:
    res: List[str] = []
    for i in range(len(options)):
        if option_list[0][i] == 1:
            res.append(options[i])

    return res


def compile_fetch_size(option_list: List[int], filename: str = "eular.c") -> int:
    in_file = os.path.dirname(os.getcwd()).replace('/', '\\') + r"\tests\samples\\" + filename
    out_file = os.path.dirname(os.getcwd()).replace('/', '\\') + r"\tests\samples\\" + "compiled.exe"
    compiler = Gcc(infile_list=[in_file], outfile=out_file,
                   f_option_list=gen_optimization_option_list_from_list(option_list))
    compiler.execute()
    size: int = fetch_file_size(out_file)
    print(size)
    return size


def bayesian_optimization(max_iter: int):
    bounds = [{'name': 'var', 'type': 'discrete', 'domain': (0, 1), 'dimensionality': len(options)}]
    opt = GPyOpt.methods.BayesianOptimization(compile_fetch_size,
                                              domain=bounds,
                                              model_type='sparseGP',
                                              acquisition_type='EI')
    opt.run_optimization(max_iter)
    opt.plot_convergence()


bayesian_optimization(30)


